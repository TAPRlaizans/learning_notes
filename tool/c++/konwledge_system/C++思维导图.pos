{"diagram":{"elements":{"note":"","watermark":"","comments":[],"data":{"right-content-index":7},"enableFreeDrag":true,"textAutoWrapWidth":900,"showWatermark":false,"title":"C++","version":0,"structure":"mind_free","children":[{"parent":"root","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"812b3a9306dd","children":[{"parent":"ac25a09c6779","children":[{"parent":"0d30cb620935","children":[],"id":"ac693a52a347","title":"常量成员变量必须在初始化列表中初始化"},{"parent":"0d30cb620935","children":[],"id":"64a45418dcb6","title":"静态成员变量只有一个，属于类，不属于对象，必须在类外定义"},{"parent":"0d30cb620935","children":[],"id":"e96a69a3139a","title":"没有默认构造函数的类成员变量必须在初始化列表中初始化"}],"id":"0d30cb620935","title":"数据成员/成员变量"},{"parent":"ac25a09c6779","children":[{"parent":"a2f2f3012ab2","children":[{"parent":"ade0b6425539","children":[],"id":"08c4fae70031","title":"构造函数"},{"parent":"ade0b6425539","children":[],"id":"9518244a85bf","title":"拷贝构造函数"},{"parent":"ade0b6425539","children":[],"id":"d8b5bf7af105","title":"赋值运算符重载"},{"parent":"ade0b6425539","children":[],"id":"23dd0acb3111","title":"析构函数"},{"parent":"ade0b6425539","children":[],"id":"d7a1dabb3343","title":"取地址运算符重载"},{"parent":"ade0b6425539","children":[],"id":"470de6f4a898","title":"const 修饰的取地址运算符重载"}],"id":"ade0b6425539","title":"类默认的六个成员函数"},{"parent":"a2f2f3012ab2","children":[{"parent":"b5b78bb709a2","children":[],"id":"ee09c52aa335","title":"const 修饰的是 this 指针"},{"parent":"b5b78bb709a2","children":[],"id":"ee3b0801c95c","title":"在函数内部不能改变 this 指针所指向的对象"},{"parent":"b5b78bb709a2","children":[],"id":"d3bda1d08466","title":"在函数内部不能调用非 const 修饰的成员函数"}],"id":"b5b78bb709a2","title":"const 修饰成员函数"},{"parent":"a2f2f3012ab2","children":[{"parent":"558e28f1acf3","children":[],"id":"5d23a99dd53c","title":"属于类不属于对象，在类的继承体系中只有一份"},{"parent":"558e28f1acf3","children":[],"id":"56278b73b9fa","title":"没有 this 指针，不能访问 非静态成员"},{"parent":"558e28f1acf3","children":[],"id":"008b850225cc","title":"最好只用静态成员函数调用静态数据成员"}],"id":"558e28f1acf3","title":"静态成员函数"}],"id":"a2f2f3012ab2","title":"成员函数/方法"},{"parent":"ac25a09c6779","children":[{"parent":"7fe759027051","children":[],"link":{"type":"url","title":"内存对齐","value":"http://blog.csdn.net/if_2016/article/details/51406579"},"id":"cb01e64c90f1","title":"对象的大小是所有数据成员的大小之和，当然也要遵循内存对齐原则"},{"parent":"7fe759027051","children":[],"id":"6042797a5576","title":"对象的大小不包括静态数据成员"},{"parent":"7fe759027051","children":[],"id":"08bd8ea7ede3","title":"对象是类的实列，类不分配空间存储，对象才分配空间用来存储"},{"parent":"7fe759027051","children":[],"id":"bf1928e67a90","title":"一个空分类对象大小是1"}],"id":"7fe759027051","title":"对象"}],"id":"ac25a09c6779","title":"类和对象"},{"parent":"812b3a9306dd","children":[{"parent":"9e47e6a5aa53","children":[],"id":"1d8780ec79c6","title":"类的成员函数默认为内联函数"},{"parent":"9e47e6a5aa53","children":[],"id":"cc9ace268fb6","title":"内敛是对编译器的一个建议"},{"parent":"9e47e6a5aa53","children":[],"id":"7cd3aed9bbf8","title":"内联必须和函数定义放在一起才起作用"},{"parent":"9e47e6a5aa53","children":[{"parent":"fbbfb9133c6d","children":[],"id":"ae84ff433f50","title":"宏有副作用，没有类型检查，不能调用"},{"parent":"fbbfb9133c6d","children":[],"id":"37f8aa2ed8d0","title":"内联 没有副作用，有类型检查，可以调试"}],"id":"fbbfb9133c6d","title":"内联与宏的区别"},{"parent":"9e47e6a5aa53","children":[],"id":"07db3a582627","title":"以空间换时间"}],"id":"9e47e6a5aa53","title":"内联 inline"},{"parent":"812b3a9306dd","children":[{"parent":"0b0688557a06","children":[{"parent":"c605d673c344","children":[],"id":"dbdb3b99e192","title":"可以在类外使用"}],"id":"c605d673c344","title":"public 公共的"},{"parent":"0b0688557a06","children":[{"parent":"0a86befe8dc8","children":[],"id":"eec8fb196a89","title":"只能在类内和派生类类内使用"}],"id":"0a86befe8dc8","title":"protect 保护的"},{"parent":"0b0688557a06","children":[{"parent":"3072c703fd1f","children":[],"id":"7e938ebc8727","title":"只能在类内使用"}],"id":"3072c703fd1f","title":"private 私有的"}],"id":"0b0688557a06","title":"访问限定符"},{"parent":"812b3a9306dd","children":[{"parent":"4d70d73dad33","children":[{"parent":"07cf3fdc472e","children":[],"id":"e3472187ad05","title":"友元函数可以访问本类中的所有成员"}],"id":"07cf3fdc472e","title":"友元函数"},{"parent":"4d70d73dad33","children":[{"parent":"468b1f971059","children":[],"id":"52f77c2a4e5e","title":"友元类可以访问本类的所有成员"}],"id":"468b1f971059","title":"友元类"},{"parent":"4d70d73dad33","children":[],"id":"2d11d07d6fad","title":"有缘关系是单向的，且不能传递，不能被继承"}],"id":"4d70d73dad33","title":"友元 friend&nbsp;"}],"id":"812b3a9306dd","title":"封装"},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"0291282e6d37","children":[{"parent":"6b301358daf4","children":[{"parent":"9e914c03c019","children":[],"id":"976359ebf4b2","title":"基类除私有成员外，其他成员访问属性不变，私有成员在子类中不可访问"}],"id":"9e914c03c019","title":"公有继承（public）"},{"parent":"6b301358daf4","children":[{"parent":"45a7903b63f7","children":[],"id":"bcb92e08ddc4","title":"基类中公有和保护成员在子类中都是保护的，基类的私有成员在子类中是不可访问的"}],"id":"45a7903b63f7","title":"保护继承 （protected）"},{"parent":"6b301358daf4","children":[{"parent":"2d773d7d529c","children":[],"id":"e55519cf4a07","title":"基类的公有和保护成员在子类中是私有的，基类的私有成员在子类中是不可访问的"}],"id":"2d773d7d529c","title":"私有继承 （private）"}],"id":"6b301358daf4","title":"继承关系"},{"parent":"0291282e6d37","children":[{"parent":"9e3fed764199","children":[],"id":"54d7d393fa96","title":"子类对象可以给父类对象赋值，父类对象不能给子类对象赋值"},{"parent":"9e3fed764199","children":[],"id":"75945f6bcbee","title":"父类的指针或引用可以指向子类对象，子类的指针或引用不能指向父类对象"}],"id":"9e3fed764199","title":"赋值兼容规则"},{"parent":"0291282e6d37","children":[{"parent":"efa66b0f1a4b","children":[],"id":"8512c75eb8ee","title":"在继承体系中基类和派生类都有独立的作用域"},{"parent":"efa66b0f1a4b","children":[],"id":"bbe946a5a356","title":"如果派生类中有和基类同名的成员，则子类成员会将基类成员进行“隐藏”，要想访问基类成员则必须加上基类的类域限定"}],"id":"efa66b0f1a4b","title":"继承过程中的作用域"},{"parent":"0291282e6d37","children":[],"id":"a4dcfa54ed9b","title":"派生类中如果没有定义类默认的六个成员函数，则派生类会自己合成"},{"parent":"0291282e6d37","children":[{"parent":"3a14493ab5fb","children":[],"id":"78fe9a38b8dd","title":"单继承：一个子类只有一个父类"},{"parent":"3a14493ab5fb","children":[],"id":"d4ddd2dd3da0","title":"多继承：一个子类有两个或两个以上的父类 （用的很少）"}],"id":"3a14493ab5fb","title":"单继承&amp;多继承"},{"parent":"0291282e6d37","children":[{"parent":"fdd9b0ae5c01","children":[],"id":"91a5d8b21c09","title":"菱形继承会导致数据沉余和二义性的问题"},{"parent":"fdd9b0ae5c01","children":[],"id":"66ae99670494","title":"虚继承可以解决菱形继承所带来的问题"}],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/51996617"},"id":"fdd9b0ae5c01","title":"菱形继承"}],"id":"0291282e6d37","title":"继承"},{"parent":"root","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"78376c5ca10c","children":[],"id":"0dd56e9c09ba","title":"允许用同样的接口来实现不同的功能，即“一个接口，多个方法”。这种在函数执行期间才确定所调用的对象，称为动态多态，动态多态实现基于赋值兼容规则和虚函数"},{"parent":"78376c5ca10c","children":[{"parent":"376d2ba88b5c","children":[],"id":"d6d97de935e6","title":"在类的成员函数前加 virtual ，则这个函数局势虚函数"},{"parent":"376d2ba88b5c","children":[],"id":"cb61a5f135ee","title":"如果在一个类中声明虚函数，那么在这个类之后的继承体系中这个函数都是虚函数"},{"parent":"376d2ba88b5c","children":[{"parent":"00ebc5cb6457","children":[],"id":"8f7efdda268f","title":"如果在子类中定义了父类中的虚函数，则成为 重写（覆盖）"},{"parent":"00ebc5cb6457","children":[],"id":"d399d66acdda","title":"重新（覆盖）是虚函数表中虚函数地址的覆盖"},{"parent":"00ebc5cb6457","children":[],"id":"2e9e30ff6524","title":"重写必须在不同的作用域中，在父类和子类中，父类中还必须有虚函数"},{"parent":"00ebc5cb6457","children":[],"id":"90228e4a8f81","title":"重写要求函数名，函数参数，返回值必须相同 （协变除外）"}],"id":"00ebc5cb6457","title":"重写"}],"id":"376d2ba88b5c","title":"虚函数（virtual）"},{"parent":"78376c5ca10c","children":[{"parent":"87bcdfbc810a","children":[],"id":"28c526d15190","title":"在虚函数的后面写=0，则这个虚函数就是纯虚函数，纯虚函数只有声明"},{"parent":"87bcdfbc810a","children":[],"id":"64d47e81034f","title":"含有纯虚函数的类叫抽象类（接口类），不能实例化对象。只有在派生类中实例化纯虚函数后才可以实例化对象"}],"id":"87bcdfbc810a","title":"纯虚函数"},{"parent":"78376c5ca10c","children":[],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52311227"},"id":"3d31a503b46f","title":"C++对象模型&amp;虚函数表"}],"id":"78376c5ca10c","title":"多态"},{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"f3b0870321dd","children":[{"parent":"1df2c04171bb","children":[],"id":"4d8ef9b1d185","title":"new：先调用operator nwe 开辟空间，在调用构造函数"},{"parent":"1df2c04171bb","children":[],"id":"9a11ffe40b24","title":"delete：先调用析构函数，在调用operator delete 释放空间"}],"id":"1df2c04171bb","title":"nwe/delete"},{"parent":"f3b0870321dd","children":[{"parent":"aaa95731ae64","children":[],"id":"fc7b81018dc5","title":"new[]会开辟4个字节来存放要开辟空间的个数"},{"parent":"aaa95731ae64","children":[],"id":"dd61c722f1ef","title":"new[]：先调用operator new[] ，在调用构造函数"},{"parent":"aaa95731ae64","children":[],"id":"7647898143bf","title":"delete[] 先析构，在调用 operator delete[]"}],"id":"aaa95731ae64","title":"nwe[]/delete[]"},{"parent":"f3b0870321dd","children":[{"parent":"8f351516e705","children":[],"id":"e62d4b86fc85","title":"在以分配的空间中调用构造函数初始化一个对象"},{"parent":"8f351516e705","note":"- nwe(place_address) type\n- new(place_address）type(initializer-list)\n- plase_address必须是一个指针，initializer-list是类型的初始化\n","children":[],"id":"50023a303d58","title":""}],"id":"8f351516e705","title":"定位 new 表达式"},{"parent":"f3b0870321dd","children":[{"parent":"dffb54158ce7","children":[],"id":"2f85f59f28fa","title":"malloc 需要计算开辟的大小，而且还要对返回值进行强制类型转换"},{"parent":"dffb54158ce7","children":[],"id":"edbe32588688","title":"nwe 不需要计算大小，而且返回值类型不需要转换"},{"parent":"dffb54158ce7","children":[],"id":"99d083b4efc4","title":"malloc 开辟空间失败返回空，new 则抛出异常"},{"parent":"dffb54158ce7","children":[],"id":"69550e373d5e","title":"malloc/free 是函数，new/delete 是关键字"},{"parent":"dffb54158ce7","children":[],"id":"4e0e473bdb26","title":"nwe/delete 会自动调用构造和析构函数"}],"id":"dffb54158ce7","title":"new/delete 和malloc/free的区别"},{"parent":"f3b0870321dd","children":[],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52370252"},"id":"6f89f9fdf6f7","title":"深度解析 new/delete和new[]/delete[]"},{"parent":"f3b0870321dd","children":[{"parent":"24500f62d6ed","children":[],"id":"d9f6a67241ea","title":"智能指针是用来管理资源的分配以及回收的"},{"parent":"24500f62d6ed","children":[],"id":"afec2be56644","title":"scoped_str/scoped_array/unique_ptr"},{"parent":"24500f62d6ed","children":[],"id":"de6ffbcfc4b6","title":"shared_ptr/share_array/weak_ptr"},{"parent":"24500f62d6ed","children":[],"id":"8682f1f7e293","title":"share_ptr 循化引用所产生的缺陷"},{"parent":"24500f62d6ed","children":[],"link":{"type":"url","title":"循化引用&定置删除器","value":"http://blog.csdn.net/if_2016/article/details/52430895"},"id":"ca54e329b7e6","title":"定置删除器"}],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52421909"},"id":"24500f62d6ed","title":"智能指针"}],"id":"f3b0870321dd","title":"内存管理"},{"parent":"root","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"f3456dacff14","children":[],"id":"97bb1d2b21c9","title":"重载又称为静态多态（绑定），编译期间确定所调用的函数"},{"parent":"f3456dacff14","children":[],"id":"41265242d961","title":"由于有重载，所有C++和C的函数命名方式不同，所以在引用C文件时写成 extern“C”"},{"parent":"f3456dacff14","children":[{"parent":"a526dc120fac","children":[],"id":"fe312149564b","title":"要在同一作用域"},{"parent":"a526dc120fac","children":[],"id":"e7843a08a1e1","title":"函数名相同，参数类型或参数个数不同，返回值可同可不同"},{"parent":"a526dc120fac","children":[],"id":"4f7309b13323","title":"重载的引入是为了减少对函数名字的记忆，所以良好的习惯是将功能类似的函数才实现成重载"}],"id":"a526dc120fac","title":"函数重载"},{"parent":"f3456dacff14","children":[{"parent":"d349bf938298","children":[{"parent":"cb10b84838e1","children":[],"id":"8ae0b02eb859","title":"声明为友元函数进行重载"},{"parent":"cb10b84838e1","children":[],"id":"9112ec289754","title":"返回值是输入流或输出流对象的引用"},{"parent":"cb10b84838e1","children":[],"id":"35c037b1dec5","title":"第一个参数是输入输出流对象的引用"}],"id":"cb10b84838e1","title":"输入输出操作符重载"},{"parent":"d349bf938298","children":[{"parent":"ee92c197ee94","children":[],"id":"ccfe3c18bc3d","title":"参数里面写个 int 代表后置"}],"id":"ee92c197ee94","title":"++和--重载"},{"parent":"d349bf938298","children":[{"parent":"9c935047bde8","children":[],"id":"bfc84c8e9ce7","title":"* /：&nbsp; ： /sizeof/?:&nbsp; /"}],"id":"9c935047bde8","title":"不能重载的操作符"}],"id":"d349bf938298","title":"运算符重载（operator）"}],"id":"f3456dacff14","title":"重载"},{"parent":"root","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"db32041a8db6","children":[{"parent":"045538597dc7","children":[],"id":"04dd43dfed04","title":"一个变量可以有多个引用"},{"parent":"045538597dc7","children":[],"id":"1a0f886a6e85","title":"引用不分配空间，引用只是变量的别名"},{"parent":"045538597dc7","children":[],"id":"6529ba084653","title":"引用必须初始化"},{"parent":"045538597dc7","children":[],"id":"ace1c22e91e7","title":"引用从一而终，只能在初始化的时候引用一次"},{"parent":"045538597dc7","children":[],"id":"d07da2f7fe89","title":"不能通过const修饰的引用改变变量的值"},{"parent":"045538597dc7","children":[],"id":"c407bc739e94","title":"引用可以作为参数传递，是实参的别名"},{"parent":"045538597dc7","children":[],"id":"a1779cbe4ac4","title":"如果不改变变量的值，尽量使用常引用传参"}],"id":"045538597dc7","title":"引用"},{"parent":"db32041a8db6","children":[{"parent":"bb4e85b08970","children":[],"id":"bffc9467d787","title":"引用只能在初始化的时候引用一次，指针的值可变"},{"parent":"bb4e85b08970","children":[],"id":"d69e69f87bfa","title":"引用必须初始化，指针可以为空"},{"parent":"bb4e85b08970","children":[],"id":"192b6c52bf5b","title":"指针的大小固定，引用的大小是变量的大小"},{"parent":"bb4e85b08970","children":[],"id":"747a90d1a21c","title":"在对引用自增和自减是引用所代表的空间的之发生变化，而指针自增自减时指针指向的位置发生变化"},{"parent":"bb4e85b08970","children":[],"id":"2349bc09b498","title":"引用比指针更高效，更灵活"}],"id":"bb4e85b08970","title":"引用与指针的区别"},{"parent":"db32041a8db6","children":[{"parent":"25c8abd8e4a1","children":[],"id":"d9e4924df379","title":"编译器把它当作常量，每次从寄存器中取值"}],"id":"25c8abd8e4a1","title":"const 修饰变量"}],"id":"db32041a8db6","title":"指针&amp;引用&amp;const"},{"parent":"root","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"329fa3aa32bf","children":[],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52289863"},"id":"21ad5fd403d7","title":"实现一个 string"},{"parent":"329fa3aa32bf","children":[],"link":{"type":"url","title":"写时拷贝","value":"http://blog.csdn.net/if_2016/article/details/52354838"},"id":"176a482c741c","title":"Copy On Write 的实现原理 --- 引用计数"}],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/51985464"},"id":"329fa3aa32bf","title":"浅拷贝与深拷贝&amp;写时拷贝"},{"parent":"root","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"78fe536479f9","children":[],"id":"b13eb716a54f","title":"模板时泛型编程的基础，泛型编程就是与1类型无关的编程，可以提高软件的重用"},{"parent":"78fe536479f9","children":[],"id":"26a0e1009330","title":"函数模板"},{"parent":"78fe536479f9","children":[{"parent":"fc4f059e0d2f","children":[],"id":"a2fb40fc7926","title":"定义对象时必须传递类型"},{"parent":"fc4f059e0d2f","children":[],"id":"703bccaf00f2","title":"在类外定义成员函数时要写模板参数列表"}],"id":"fc4f059e0d2f","title":"类模板"},{"parent":"78fe536479f9","children":[{"parent":"a130470da3a8","children":[],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52327530"},"id":"2b66cec69511","title":"模板的模板参数，实现容器适配器"},{"parent":"a130470da3a8","children":[],"id":"b22d72987819","title":"非类型的模板参数"}],"id":"a130470da3a8","title":"模板参数"},{"parent":"78fe536479f9","children":[{"parent":"759abb02b78b","children":[],"id":"aef847cb0a1f","title":"全特化后在定义车成员函数不需要模板参数"},{"parent":"759abb02b78b","children":[],"id":"a1774dd175b0","title":"全特化和偏特化都是在模板的基础上，不能单独存在"}],"id":"759abb02b78b","title":"全特化与编特化"},{"parent":"78fe536479f9","children":[{"parent":"ab933f1a0471","children":[],"id":"a2cb605ccd51","title":"基于模板的全特化，区分内置类型和自定义类型"}],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52434494"},"id":"ab933f1a0471","title":"类型萃取"},{"parent":"78fe536479f9","children":[{"parent":"389cac740d81","children":[],"id":"18053e6cb9fe","title":"因为编译和链接是分开的，所以将声明和定义单独编译时，链接会出错"},{"parent":"389cac740d81","children":[],"id":"63e8400bdbae","title":"将声明和定义放到一个“xxx.cpp”的头文件里面"}],"id":"389cac740d81","title":"模板的分离编译"}],"id":"78fe536479f9","title":"模板（TEMPLATE）"},{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"b9209c3dec7f","children":[{"parent":"6be0dd4c5a7b","children":[],"id":"8b273a1eb473","title":"static_cast用于非多态类型转换（静态转换），任何标准类型都可以使用它。它只能用于两个关联的类型转换"}],"id":"6be0dd4c5a7b","title":"static_cast"},{"parent":"b9209c3dec7f","children":[{"parent":"7f57b3131642","children":[],"id":"aff654d551dd","title":"reinterpret_cast用于将一种类型转换成另一种不同的类型。只能转化不相关的类型"}],"id":"7f57b3131642","title":"reinterpret_cast"},{"parent":"b9209c3dec7f","children":[{"parent":"40d8251244d4","children":[],"id":"6df34e13d12e","title":"const_cast删除变量const属性，方便赋值"}],"id":"40d8251244d4","title":"const_cast"},{"parent":"b9209c3dec7f","children":[{"parent":"ed54545e36b9","children":[],"id":"c63998b8d75b","title":"将一个父类的指针或引用转换成一个子类的指针或引用（动态转换）。如不能转换则返回空"}],"id":"ed54545e36b9","title":"dynamic_cast"},{"parent":"b9209c3dec7f","children":[],"id":"6e650ee3fcd7","title":"explicit 防止构造函数隐式类型转换"}],"link":{"type":"url","title":"","value":"http://blog.csdn.net/if_2016/article/details/52434507"},"id":"b9209c3dec7f","title":"强制类型转换"},{"parent":"root","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"10282ccc73fa","children":[],"id":"de5f9bede70c","title":"命名空间是为了解决命名冲突"},{"parent":"10282ccc73fa","children":[],"id":"c2de04be1478","title":"namespace"}],"link":{"type":"url","title":"","value":"http://blog.csdn.net/lf_2016/article/details/51930792"},"id":"10282ccc73fa","title":"命名空间"},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"7e462dd50690","children":[],"id":"9e9c2e5b59ef","title":"当函数发现一个自己无法处理的错误时，抛出异常，由函数的调用者处理"},{"parent":"7e462dd50690","children":[{"parent":"16eb10003b2f","children":[],"id":"31251365ca6d","title":"异常的捕捉是根据类型决定的，而不是根据对象决定的"},{"parent":"16eb10003b2f","children":[],"id":"5c75102e64b8","title":"抛出的异常会被离它最近的，且类型相同的catch捕获，要是没有捕获，则程序会自动结束掉"}],"id":"16eb10003b2f","title":"try/throw/catch"},{"parent":"7e462dd50690","children":[],"id":"d608887d31d4","title":"异常会改变程序执行的流程，会带来一系列的问题。异常的使用有栈展开的过程，会降低程序效率"}],"id":"7e462dd50690","title":"异常处理"},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"196ac8b7e299","children":[],"id":"b931f59cef76","title":"全局域"},{"parent":"196ac8b7e299","children":[],"id":"5ef4adb97251","title":"局部域"},{"parent":"196ac8b7e299","children":[],"id":"7f849a0e11dc","title":"名字空间域"}],"id":"196ac8b7e299","title":"C++中的作用域"},{"parent":"root","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"f406ca755ed5","children":[{"parent":"b765d14371bf","children":[],"id":"c14d5670bd9a","title":"语言内部已经定义的类型称为内置类型"},{"parent":"b765d14371bf","children":[],"id":"b1147e2b8a3e","title":"字符char"},{"parent":"b765d14371bf","children":[],"id":"a066f3316ebf","title":"整形 int"},{"parent":"b765d14371bf","children":[],"id":"91085bcc9533","title":"浮点型 float/double"},{"parent":"b765d14371bf","children":[],"id":"844fcd6c4158","title":"逻辑型 bool"},{"parent":"b765d14371bf","children":[],"id":"3241d92fc75c","title":"无类型 void"}],"id":"b765d14371bf","title":"基本（内置）数据类型"},{"parent":"f406ca755ed5","children":[{"parent":"e22893a57329","children":[],"id":"d7d4c7290063","title":"数组 ，指针，struct，union，enum，class"},{"parent":"e22893a57329","children":[],"id":"10367bf3b748","title":"在C++中struct和class除了默认的访问属性不同外，其余基本相同"}],"id":"e22893a57329","title":"非基本类型"},{"parent":"f406ca755ed5","children":[],"id":"e113e3ac0187","title":"C++ 中公有63个关键字"}],"id":"f406ca755ed5","title":"数据类型"},{"parent":"root","lineStyle":{"randomLineColor":"#FCB52A"},"children":[{"parent":"9362e05d5044","children":[{"parent":"3c2399ebfc0d","image":{"w":900,"h":119.90008326394671,"url":"http://cdn.processon.com/634a086c0e3e740c570a2cf3?e=1665799804&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:y6wedspZwakztF69svLTZQv5uOs=","direction":"down"},"children":[],"id":"613c2ef23251","title":""}],"id":"3c2399ebfc0d","title":"STl库"},{"parent":"9362e05d5044","children":[{"parent":"4b835adce783","children":[{"parent":"97315a3db48f","image":{"w":800,"h":119,"url":"http://cdn.processon.com/634a097be0b34d40be692a31?e=1665800075&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:5GPsg5LFw3ABKeaqjwE3y1LwtMQ=","direction":"left"},"children":[],"id":"60c74774404d","title":""},{"parent":"97315a3db48f","image":{"w":803,"h":201,"url":"http://cdn.processon.com/634a099f0e3e740c570a2e1f?e=1665800111&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:cneGk1BmxirJ00uDCyhYSiORpfI=","direction":"left"},"children":[],"id":"ad68dc12548d","title":""},{"parent":"97315a3db48f","image":{"w":803,"h":127,"url":"http://cdn.processon.com/634a09a9637689070a5460d0?e=1665800121&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:t9fUDA9Mq748YNy3F--P8TALrMY=","direction":"left"},"children":[],"id":"10b647c377d3","title":""},{"parent":"97315a3db48f","image":{"w":804,"h":165,"url":"http://cdn.processon.com/634a09b91e0853071430094e?e=1665800137&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:7fFB-cZlA8tKaquoumShDbBzjtA=","direction":"left"},"children":[],"id":"a745434fe7a9","title":""},{"parent":"97315a3db48f","image":{"w":824,"h":448,"url":"http://cdn.processon.com/634a09c11e08530714300959?e=1665800145&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:EPLqCgkU5FaLfqOfZmm_Ai7Ux_k=","direction":"left"},"children":[],"id":"b3a518fd48c7","title":""}],"id":"97315a3db48f","title":"迭代器操作"}],"id":"4b835adce783","title":"迭代器 iterator"}],"id":"9362e05d5044","title":"容器"}],"background":"#BBDEFB","freeChildren":[{"layout":"mind_right","parent":"root","lineStyle":{"randomLineColor":"#FCB52A"},"children":[],"pos":{"x":-399,"y":6},"id":"3396d3bbcf11","title":"自由主题","free":true}],"root":true,"theme":"delicate_caihong","id":"root"}},"meta":{"exportTime":"2025-07-03 13:00:12","member":"","diagramInfo":{"creator":"","created":"2025-07-03 12:59:37","modified":"2025-07-03 12:59:40","title":"C++思维导图","category":"mind_free"},"id":"68660e39a17ef716c1a73fee","cloneId":"6348a78d0e3e740c57073273","type":"ProcessOn Schema File","version":"5.0"}}